=head1 NAME

perlfaq10 - Testing perl

=head1 DESCRIPTION

This section of the FAQ answers questions related to testing perl modules
and scripts.

=head2 How can I run module tests?

You can run any test file with

    $ perl -Ilib t/23.sometest.t

You will get detailed output of the single tests and any STDOUT and STDERR
output.

C<prove> is a more advanced tool which by default will give you a summary
in colored output, without STDOUT.

    $ prove t/23.sometest.t

To run all test files you usually do

    $ prove -lr t
    # -r recurse through t
    # -l: same as perl -I lib

See

    $ perldoc prove

for all the various options.

=head2 How can I test a script?

Making a system call to the script and checking its output and exit code
is one method. This might not be enough for covering every test case, and
simulating behaviour can be more cumbersome.

If you have to deal with a script that has one C<main> subroutine you can at
least do this:

    main() unless caller(0);

    sub main {
        ...
    }

C<main()> will not be called when being C<require>d by another script.

You can then test it by doing

    use FindBin '$Bin';
    local @ARGV = qw/ --do-something /;
    require "$Bin/../bin/script.pl";
    my $result = main();
    ...

More and smaller subroutines result in better testing possibilities.

=head2 How can I catch errors, warnings, STDERR or STDOUT?

L<Test::Trap> is a module which lets you catch output of the code,
exit, die, warnings without messing with the dirty stuff like replacing
core functions yourself.

=head2 How can I mock a subroutine or a module?

With mocking you can test your code by replacing real functionality
(usually from other modules you use in your code) with simulated.

It's useful when the real code would require network
and you don't have it or don't want to use it; database connection,
hardware, ...

It's also useful for simulating errors or situations that you cannot
produce yourself - database connection timeout, changing the system time, ...

Replacing one subroutine with another can be done with L<Sub::Override>
for example:

    use Sub::Override;
    my $override = Sub::Override->new( "Other::Module::foo" => sub {
        my (@args) = @_;
        ...
    });
    ...
    $override->restore; # get back original functionality

For other tasks there already exist mocking modules, for example
L<Test::MockTime>, which replaces the time with simulated time.

=head2 How can I automate tests and process test results?

Sometimes there is the need to process tests yourself instead of just
getting the usual C<prove> output.

In Continuous Integration systems you might need to provide XML
output. There is L<TAP::Harness::JUnit> which you can use with Jenkins, for
example.

To produce your own output, you may use L<TAP::Parser::Aggregator>.

=head2 How can I make my test suite faster?

Tests can take a lot of time. You can run several test files in parallel by
calling prove like this:

    $ prove -j 9 -lr t

This will run 9 tests in parallel.

There are modules on CPAN that can't be tested like that. In most cases it's
because the author just didn't think of that while writing the tests.
A common error is that several test files use the same temp file paths
which results in broken test results.

Have that in mind when writing your tests. If you can't avoid several tests
using the same resources use a locking mechanism.


